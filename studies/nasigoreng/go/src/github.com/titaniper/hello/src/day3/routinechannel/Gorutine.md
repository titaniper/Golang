# TL;DR
- 스케줄링을 커널에 맡길 수 있는데 고루틴은 직접한다.
- 오버헤드가 적다.
- 커널 스레드는 무겁다. 기본적으로 운영체제에서 생성, 삭제하는 과정 있어서, 그리고 스레드 당 스택 메모리가 커서 낭비가 있다.


고루틴이 Java의 스레드와 비교해서 왜 빠른지에 대한 이유를 설명하려면, 각 언어에서의 스레드 관리 방식과 런타임 환경의 차이를 이해하는 것이 중요합니다. Java와 Go의 스레드 관리 방식을 비교하면서, 고루틴이 왜 더 빠르고 효율적인지 설명해보겠습니다.

Java 스레드
Java 스레드 관리:

Java 스레드는 기본적으로 커널 수준의 스레드(Kernel-Level Thread, KLT)를 사용합니다. 이는 운영 체제의 스케줄러에 의해 관리됩니다.
Java에서 스레드를 생성하고 관리하는 과정은 JVM(Java Virtual Machine)에 의해 이루어집니다. JVM은 OS 커널의 스레드를 생성하고 관리하는 데 도움을 줍니다.
문맥 전환 오버헤드:

Java 스레드는 커널 수준에서 관리되므로, 문맥 전환 시 커널 모드 전환이 필요합니다. 이는 비교적 높은 오버헤드를 발생시킵니다.
여러 스레드 간의 문맥 전환이 빈번하게 발생하면 성능 저하가 발생할 수 있습니다.
스레드 생성과 소멸:

Java 스레드의 생성과 소멸은 비교적 무거운 작업입니다. 이는 운영 체제에서 스레드를 생성하고 제거하는 과정이 포함되기 때문입니다.
스레드 하나당 할당되는 스택 메모리가 크기 때문에 메모리 사용량도 많습니다.
Go 고루틴
고루틴 관리:

고루틴은 Go 런타임에 의해 관리되는 경량 수준의 스레드(User-Level Thread, ULT)입니다.
고루틴은 매우 작은 초기 스택 크기로 시작하며, 필요에 따라 동적으로 확장됩니다.
문맥 전환 오버헤드:

고루틴 간의 문맥 전환은 Go 런타임이 사용자 공간에서 처리합니다. 따라서 커널 모드 전환이 필요하지 않으며, 매우 적은 오버헤드로 문맥 전환이 이루어집니다.
이는 고루틴 간의 문맥 전환이 함수 호출 정도의 오버헤드만을 발생시킴을 의미합니다.
고루틴 생성과 소멸:

고루틴의 생성과 소멸은 매우 빠릅니다. Go 런타임이 이를 효율적으로 관리하며, 초기 스택 크기가 작아 메모리 사용량도 적습니다.
고루틴 생성과 소멸이 사용자 공간에서 처리되므로, 커널 호출에 따른 오버헤드가 없습니다.
비교 요약
스레드 생성과 소멸:

Java: 커널 스레드 사용으로 인해 스레드 생성과 소멸이 비교적 무겁고 메모리 사용량이 많음.
Go: 고루틴은 경량 구조로 매우 빠르게 생성 및 소멸되며, 메모리 사용량이 적음.
문맥 전환 오버헤드:

Java: 커널 모드 전환이 필요하여 문맥 전환 오버헤드가 큼.
Go: 사용자 공간에서 문맥 전환이 이루어져 오버헤드가 작음.
스케줄링:

Java: 커널에 의한 스케줄링으로 커널 스케줄러의 영향을 받음.
Go: Go 런타임의 사용자 수준 스케줄링으로 효율적이며, 커널 스케줄러의 영향을 덜 받음.
결론
고루틴이 Java의 스레드에 비해 빠른 이유는 고루틴의 경량성, 빠른 생성과 소멸, 그리고 사용자 공간에서의 효율적인 스케줄링 때문입니다. 이러한 특성들은 고루틴이 수천 개의 동시 작업을 처리할 때도 성능 저하 없이 효율적으로 동작할 수 있게 합니다. Java의 스레드는 커널 수준에서 관리되기 때문에 상대적으로 무겁고, 문맥 전환 오버헤드가 크며, 스레드 생성과 소멸이 느린 반면, 고루틴은 이러한 오버헤드가 최소화되어 고성능과 효율성을 제공합니다.


고루틴(Goroutine)은 Go 언어에서 제공하는 경량의 실행 단위로, User Level Thread (ULT)와 Kernel Level Thread (KLT)의 특징을 모두 가지고 있습니다. 하지만, 기본적으로 고루틴은 ULT에 더 가깝다고 할 수 있습니다. 아래에 고루틴의 특징과 ULT 및 KLT와의 관계를 설명합니다.

고루틴의 특징
경량성:

고루틴은 매우 가벼운 실행 단위로, 수천 개의 고루틴을 생성해도 시스템 자원에 큰 부담을 주지 않습니다.
이는 일반적인 스레드보다 훨씬 적은 메모리를 사용합니다.
User Level 관리:

고루틴은 Go 런타임이 사용자 수준에서 관리합니다. 고루틴 간의 스케줄링과 문맥 전환은 Go 런타임이 담당합니다.
이로 인해 문맥 전환이 빠르고 효율적입니다.
멀티플렉싱:

Go 런타임은 여러 고루틴을 하나 또는 여러 개의 커널 스레드 위에 멀티플렉싱합니다. 즉, 여러 고루틴이 하나의 커널 스레드를 공유할 수 있습니다.
Go 런타임이 고루틴의 실행을 커널 스레드에 분배하고 관리하므로, 고루틴 자체는 커널 스레드에 비해 훨씬 가벼운 ULT처럼 동작합니다.
ULT와의 유사점
스케줄링: 고루틴의 스케줄링은 Go 런타임에서 관리되며, 이는 ULT의 스케줄링 방식과 유사합니다.
경량성: 고루틴은 ULT처럼 매우 가볍고, 문맥 전환 오버헤드가 적습니다.
KLT와의 유사점
병렬 처리: 고루틴은 Go 런타임에 의해 여러 커널 스레드에 분배될 수 있으므로, 멀티 코어 시스템에서 병렬 처리가 가능합니다.
블로킹 처리: 하나의 고루틴이 블록되더라도, 다른 고루틴은 다른 커널 스레드에서 실행될 수 있어 전체 애플리케이션의 동작이 멈추지 않습니다.
결론
고루틴은 기본적으로 User Level Thread (ULT)로 동작하지만, Go 런타임이 이를 관리하여 여러 커널 스레드에서 병렬로 실행될 수 있도록 지원합니다. 따라서 고루틴은 ULT와 KLT의 장점을 모두 활용하는 방식으로 설계되어 있으며, 이러한 특성 덕분에 고루틴을 사용한 프로그램은 매우 효율적이고 확장성이 뛰어납니다.



네, 정확합니다. Go의 고루틴에서는 스레드 생성과 전환이 사용자 레벨에서 제어됩니다. 이를 좀 더 자세히 설명하겠습니다.

사용자 레벨에서의 제어
고루틴의 생성:

고루틴은 Go 런타임에 의해 관리되며, go 키워드를 통해 쉽게 생성됩니다.
고루틴은 사용자 공간에서 생성되며, 커널 스레드를 직접 생성하는 것이 아니라, Go 런타임이 관리하는 경량 스레드를 생성하는 것입니다.
초기 스택 크기가 작아 생성 시 메모리 사용이 적고 빠릅니다.
문맥 전환:

고루틴 간의 문맥 전환은 Go 런타임 스케줄러에 의해 제어됩니다. 이 스케줄러는 사용자 공간에서 동작하며, 고루틴 간의 문맥 전환을 효율적으로 처리합니다.
문맥 전환이 사용자 공간에서 이루어지기 때문에, 커널 모드로 전환할 필요가 없어 오버헤드가 매우 적습니다.
스케줄링:

Go 런타임 스케줄러는 M
매핑을 사용합니다. 이는 많은 고루틴(M)을 적은 수의 커널 스레드(N)에 매핑하여 실행하는 방식입니다.
Go 런타임 스케줄러는 고루틴을 커널 스레드에 분배하고, 필요할 때 고루틴 간 문맥 전환을 수행합니다.
이 과정에서 커널의 스케줄러를 사용하지 않고, Go 런타임이 사용자 공간에서 스케줄링을 처리합니다.
사용자 레벨 제어의 장점
빠른 생성과 소멸:

고루틴의 생성과 소멸이 빠릅니다. 이는 커널 스레드를 생성하는 오버헤드가 없기 때문입니다.
고루틴은 매우 작은 초기 스택으로 시작하고, 필요에 따라 동적으로 확장됩니다.
낮은 문맥 전환 오버헤드:

문맥 전환이 사용자 공간에서 이루어지므로, 커널 모드 전환에 따른 오버헤드가 없습니다.
고루틴 간의 문맥 전환은 단순히 Go 런타임에서의 함수 호출 정도의 오버헤드만을 발생시킵니다.
효율적인 스케줄링:

Go 런타임 스케줄러는 고루틴을 효율적으로 분배하여 커널 스레드 간의 부하를 균등하게 분산시킵니다.
Work Stealing 알고리즘을 사용하여, 비활성화된 커널 스레드의 작업을 활성화된 커널 스레드로 이동시켜 효율성을 극대화합니다.
결론
고루틴의 생성과 문맥 전환은 사용자 레벨에서 제어되며, 이는 고루틴이 매우 경량하고 효율적인 이유 중 하나입니다. 사용자 레벨에서의 제어 덕분에 고루틴은 빠르게 생성되고, 문맥 전환 오버헤드가 적으며, Go 런타임 스케줄러가 효율적으로 고루틴을 관리할 수 있습니다. 이와 같은 특성 덕분에 고루틴은 수많은 동시 작업을 처리할 때도 성능 저하 없이 동작할 수 있습니다.